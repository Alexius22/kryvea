package db

// type Vulnerability struct {
// 	Model
// 	CategoryID         string     `json:"category_id"`
// 	Category           Category   `json:"category"`
// 	DetailedTitle      string     `json:"detailed_title"`
// 	CVSSVector         string     `json:"cvss_vector"`
// 	CVSSScore          float64    `json:"cvss_score"`
// 	References         string     `json:"references"`
// 	GenericDescription bool       `json:"generic_description"`
// 	GenericRemediation bool       `json:"generic_remediation"`
// 	Description        string     `json:"description"`
// 	Remediation        string     `json:"remediation"`
// 	TargetID           string     `json:"target_id"`
// 	Target             Target     `json:"-"`
// 	AssessmentID       string     `json:"assessment_id"`
// 	Assessment         Assessment `json:"-"`
// }

// func AddVulnerability(vulnerability Vulnerability) error {
// 	result := Database.First(&Category{}, Model{ID: vulnerability.CategoryID})
// 	if result.Error != nil {
// 		return result.Error
// 	}

// 	var assessment Assessment
// 	result = Database.Model(&Assessment{}).Preload("Targets").First(&assessment, Model{ID: vulnerability.AssessmentID})
// 	if result.Error != nil {
// 		return result.Error
// 	}

// 	if !ContainsTargetID(assessment.Targets, vulnerability.TargetID) {
// 		return errors.New("Target ID not found in assessment")
// 	}

// 	result = Database.Create(&vulnerability)
// 	if result.Error != nil {
// 		return result.Error
// 	}
// 	if result.RowsAffected == 0 {
// 		return errors.New("Failed to create vulnerability")
// 	}
// 	return nil
// }

// func ContainsTargetID(targets []Target, targetID string) bool {
// 	for _, target := range targets {
// 		if target.ID == targetID {
// 			return true
// 		}
// 	}
// 	return false
// }

// func GetAllVulnerabilities() ([]Vulnerability, error) {
// 	var vulnerabilities []Vulnerability
// 	result := Database.Model(&Vulnerability{}).Preload("Category").Find(&vulnerabilities)
// 	if result.Error != nil {
// 		return vulnerabilities, result.Error
// 	}
// 	return vulnerabilities, nil
// }

// func GetAllVulnerabilitiesByTargetID(targetID string) ([]Vulnerability, error) {
// 	if targetID == "" {
// 		return nil, errors.New("Target ID is required")
// 	}

// 	var vulnerabilities []Vulnerability
// 	result := Database.Model(&Vulnerability{}).Preload("Category").Find(&vulnerabilities, Vulnerability{TargetID: targetID})
// 	if result.Error != nil {
// 		return vulnerabilities, result.Error
// 	}
// 	return vulnerabilities, nil
// }

// func GetAllVulnerabilitiesByAssessmentID(assessmentID string) ([]Vulnerability, error) {
// 	if assessmentID == "" {
// 		return nil, errors.New("Assessment ID is required")
// 	}

// 	var vulnerabilities []Vulnerability
// 	result := Database.Model(&Vulnerability{}).Preload("Category").Find(&vulnerabilities, Vulnerability{AssessmentID: assessmentID})
// 	if result.Error != nil {
// 		return vulnerabilities, result.Error
// 	}
// 	return vulnerabilities, nil
// }

// func GetVulnerabilityByID(id string) (Vulnerability, error) {
// 	if id == "" {
// 		return Vulnerability{}, errors.New("ID is required")
// 	}

// 	var vulnerability Vulnerability
// 	result := Database.Model(&Vulnerability{}).Preload("Category").First(&vulnerability, Model{ID: id})
// 	if result.Error != nil {
// 		return vulnerability, result.Error
// 	}
// 	if result.RowsAffected == 0 {
// 		return vulnerability, errors.New("Vulnerability not found")
// 	}
// 	return vulnerability, nil
// }

// func GetVulnerabilitiesByType(vulnType string) ([]Vulnerability, error) {
// 	if vulnType == "" {
// 		return nil, errors.New("Vulnerability type is required")
// 	}

// 	var vulnerabilities []Vulnerability
// 	result := Database.Model(&Vulnerability{}).Preload("Category").Find(&vulnerabilities, "category ILIKE ?", "%"+sanitizeLikeQuery(vulnType)+"%")
// 	if result.Error != nil {
// 		return vulnerabilities, result.Error
// 	}
// 	return vulnerabilities, nil
// }
