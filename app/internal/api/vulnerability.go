package api

import (
	"fmt"

	"github.com/Alexius22/kryvea/internal/cvss"
	"github.com/Alexius22/kryvea/internal/mongo"
	"github.com/Alexius22/kryvea/internal/util"
	"github.com/gofiber/fiber/v2"
	"go.mongodb.org/mongo-driver/v2/bson"
)

func (d *Driver) AddVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	type reqData struct {
		Category           string   `json:"category"`
		DetailedTitle      string   `json:"detailed_title"`
		CVSSv2             string   `json:"cvssv2_vector"`
		CVSSv3             string   `json:"cvssv3_vector"`
		CVSSv31            string   `json:"cvssv31_vector"`
		CVSSv4             string   `json:"cvssv4_vector"`
		References         []string `json:"references"`
		GenericDescription bool     `json:"generic_description"`
		GenericRemediation bool     `json:"generic_remediation"`
		Description        string   `json:"description"`
		Remediation        string   `json:"remediation"`
		TargetID           string   `json:"target_id"`
	}

	data := &reqData{}
	if err := c.BodyParser(data); err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot parse JSON",
		})
	}

	assessmentParam := c.Params("assessment")
	if assessmentParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Assessment ID is required",
		})
	}

	assessmentID, err := util.ParseMongoID(assessmentParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	assessment, err := d.mongo.Assessment().GetByID(assessmentID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	if !util.CanAccessCustomer(user, assessment.Customer.ID) {
		c.Status(fiber.StatusUnauthorized)
		return c.JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	categoryID, err := util.ParseMongoID(data.Category)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid category",
		})
	}

	_, err = d.mongo.Category().GetByID(categoryID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid category",
		})
	}

	targetID, err := util.ParseMongoID(data.TargetID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid target ID",
		})
	}

	_, err = d.mongo.Target().GetByID(targetID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid target ID",
		})
	}

	customer, err := d.mongo.Customer().GetByID(assessment.Customer.ID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get customer",
		})
	}

	vuln := &mongo.Vulnerability{
		Category: mongo.VulnerabilityCategory{
			ID: categoryID,
		},
		DetailedTitle: data.DetailedTitle,
		References:    data.References,
		GenericDescription: mongo.VulnerabilityGeneric{
			Enabled: data.GenericDescription,
		},
		GenericRemediation: mongo.VulnerabilityGeneric{
			Enabled: data.GenericRemediation,
		},
		Description: data.Description,
		Remediation: data.Remediation,
		Target: mongo.VulnerabilityTarget{
			ID: targetID,
		},
		Assessment: mongo.VulnerabilityAssessment{
			ID: assessmentID,
		},
		User: mongo.VulnerabilityUser{
			ID: user.ID,
		},
	}

	vulnerabilityCvss, err := parseAndAssignCVSS(data.CVSSv2, cvss.CVSS2, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv2 vector",
		})
	}
	vuln.CVSSv2 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv3, cvss.CVSS3, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv3 vector",
		})
	}
	vuln.CVSSv3 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv31, cvss.CVSS31, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv31 vector",
		})
	}
	vuln.CVSSv31 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv4, cvss.CVSS4, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv4 vector",
		})
	}
	vuln.CVSSv4 = vulnerabilityCvss

	vulnerabilityID, err := d.mongo.Vulnerability().Insert(vuln)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Failed to add vulnerability",
		})
	}

	c.Status(fiber.StatusCreated)
	return c.JSON(fiber.Map{
		"message":          "Vulnerability created",
		"vulnerability_id": vulnerabilityID.Hex(),
	})
}

func (d *Driver) UpdateVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	type reqData struct {
		Category           string   `json:"category"`
		DetailedTitle      string   `json:"detailed_title"`
		CVSSv2             string   `json:"cvssv2_vector"`
		CVSSv3             string   `json:"cvssv3_vector"`
		CVSSv31            string   `json:"cvssv31_vector"`
		CVSSv4             string   `json:"cvssv4_vector"`
		References         []string `json:"references"`
		GenericDescription bool     `json:"generic_description"`
		GenericRemediation bool     `json:"generic_remediation"`
		Description        string   `json:"description"`
		Remediation        string   `json:"remediation"`
		TargetID           string   `json:"target_id"`
	}

	data := &reqData{}
	if err := c.BodyParser(data); err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot parse JSON",
		})
	}

	assessmentParam := c.Params("assessment")
	if assessmentParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Assessment ID is required",
		})
	}

	assessmentID, err := util.ParseMongoID(assessmentParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	assessment, err := d.mongo.Assessment().GetByID(assessmentID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	if !util.CanAccessCustomer(user, assessment.Customer.ID) {
		c.Status(fiber.StatusUnauthorized)
		return c.JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	vulnerabilityParam := c.Params("vulnerability")

	if vulnerabilityParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Vulnerability ID is required",
		})
	}

	vulnerabilityID, err := util.ParseMongoID(vulnerabilityParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	_, err = d.mongo.Vulnerability().GetByAssessmentAndID(assessment.ID, vulnerabilityID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	categoryID, err := util.ParseMongoID(data.Category)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid category",
		})
	}

	_, err = d.mongo.Category().GetByID(categoryID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid category",
		})
	}

	targetID, err := util.ParseMongoID(data.TargetID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid target ID",
		})
	}

	_, err = d.mongo.Target().GetByID(targetID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid target ID",
		})
	}

	customer, err := d.mongo.Customer().GetByID(assessment.Customer.ID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get customer",
		})
	}

	vuln := &mongo.Vulnerability{
		Category: mongo.VulnerabilityCategory{
			ID: categoryID,
		},
		DetailedTitle: data.DetailedTitle,
		References:    data.References,
		GenericDescription: mongo.VulnerabilityGeneric{
			Enabled: data.GenericDescription,
		},
		GenericRemediation: mongo.VulnerabilityGeneric{
			Enabled: data.GenericRemediation,
		},
		Description: data.Description,
		Remediation: data.Remediation,
		Target: mongo.VulnerabilityTarget{
			ID: targetID,
		},
	}

	vulnerabilityCvss, err := parseAndAssignCVSS(data.CVSSv2, cvss.CVSS2, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv2 vector",
		})
	}
	vuln.CVSSv2 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv3, cvss.CVSS3, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv3 vector",
		})
	}
	vuln.CVSSv3 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv31, cvss.CVSS31, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv31 vector",
		})
	}
	vuln.CVSSv31 = vulnerabilityCvss

	vulnerabilityCvss, err = parseAndAssignCVSS(data.CVSSv4, cvss.CVSS4, customer.Language)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid CVSSv4 vector",
		})
	}
	vuln.CVSSv4 = vulnerabilityCvss

	err = d.mongo.Vulnerability().Update(vulnerabilityID, vuln)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Failed to update vulnerability",
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(fiber.Map{
		"message": "Vulnerability updated",
	})
}

func (d *Driver) DeleteVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	assessmentParam := c.Params("assessment")
	if assessmentParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Assessment ID is required",
		})
	}

	assessmentID, err := util.ParseMongoID(assessmentParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	assessment, err := d.mongo.Assessment().GetByID(assessmentID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	if !util.CanAccessCustomer(user, assessment.Customer.ID) {
		c.Status(fiber.StatusUnauthorized)
		return c.JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	vulnerabilityParam := c.Params("vulnerability")
	if vulnerabilityParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Assessment ID is required",
		})
	}

	vulnerabilityID, err := util.ParseMongoID(vulnerabilityParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	_, err = d.mongo.Vulnerability().GetByAssessmentAndID(assessment.ID, vulnerabilityID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	err = d.mongo.Vulnerability().Delete(vulnerabilityID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot delete vulnerability",
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(fiber.Map{
		"message": "Vulnerability deleted",
	})
}

func (d *Driver) SearchVulnerabilities(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	query := c.Query("query")
	if query == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Query is required",
		})
	}

	if len(user.Customers) == 0 && user.Role != mongo.ROLE_ADMIN {
		c.Status(fiber.StatusOK)
		return c.JSON([]mongo.Vulnerability{})
	}

	var userCustomers []bson.ObjectID
	for _, customerID := range user.Customers {
		userCustomers = append(userCustomers, customerID.ID)
	}

	vulnerabilities, err := d.mongo.Vulnerability().Search(userCustomers, query)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot search vulnerabilities",
		})
	}

	if vulnerabilities == nil {
		vulnerabilities = []mongo.Vulnerability{}
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerabilities)
}

func (d *Driver) GetVulnerabilitiesByAssessment(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	assessmentParam := c.Params("assessment")
	if assessmentParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Assessment ID is required",
		})
	}

	assessmentID, err := util.ParseMongoID(assessmentParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	assessment, err := d.mongo.Assessment().GetByID(assessmentID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid assessment ID",
		})
	}

	if !util.CanAccessCustomer(user, assessment.Customer.ID) {
		c.Status(fiber.StatusUnauthorized)
		return c.JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	vulnerabilities, err := d.mongo.Vulnerability().GetByAssessmentID(assessmentID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get vulnerabilities",
		})
	}

	customer, err := d.mongo.Customer().GetByID(assessment.Customer.ID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get customer",
		})
	}

	for i := range vulnerabilities {
		category, err := d.mongo.Category().GetByID(vulnerabilities[i].Category.ID)
		if err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(fiber.Map{
				"error": "Cannot get category",
			})
		}

		if vulnerabilities[i].GenericDescription.Enabled {
			vulnerabilities[i].GenericDescription.Text = category.GenericDescription[customer.Language]
		}

		if vulnerabilities[i].GenericRemediation.Enabled {
			vulnerabilities[i].GenericRemediation.Text = category.GenericRemediation[customer.Language]
		}
	}

	if vulnerabilities == nil {
		vulnerabilities = []mongo.Vulnerability{}
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerabilities)
}

func parseAndAssignCVSS(vector string, version string, lang string) (mongo.VulnerabilityCVSS, error) {
	if vector == "" {
		return mongo.VulnerabilityCVSS{}, nil
	}

	score, severity, err := cvss.ParseVector(vector, version)
	if err != nil {
		return mongo.VulnerabilityCVSS{}, fmt.Errorf("invalid CVSS vector")
	}

	return mongo.VulnerabilityCVSS{
		CVSSVector:      vector,
		CVSSScore:       score,
		CVSSSeverity:    severity,
		CVSSDescription: cvss.GenerateDescription(vector, version, lang),
	}, nil
}
