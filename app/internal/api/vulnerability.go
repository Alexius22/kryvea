package api

import (
	"errors"

	"github.com/Alexius22/kryvea/internal/cvss"
	"github.com/Alexius22/kryvea/internal/mongo"
	"github.com/Alexius22/kryvea/internal/util"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

type vulnerabilityRequestData struct {
	CategoryID         string   `json:"category_id"`
	DetailedTitle      string   `json:"detailed_title"`
	Status             string   `json:"status"`
	CVSSv2             string   `json:"cvssv2_vector"`
	CVSSv3             string   `json:"cvssv3_vector"`
	CVSSv31            string   `json:"cvssv31_vector"`
	CVSSv4             string   `json:"cvssv4_vector"`
	References         []string `json:"references"`
	GenericRemediation bool     `json:"generic_remediation"`
	Description        string   `json:"description"`
	Remediation        string   `json:"remediation"`
	TargetID           string   `json:"target_id"`
	AssessmentID       string   `json:"assessment_id"`
}

func (d *Driver) AddVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	data := &vulnerabilityRequestData{}
	if err := c.BodyParser(data); err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot parse JSON",
		})
	}

	// parse assessment param
	assessment, errStr := d.assessmentFromParam(data.AssessmentID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	// get category from database
	category, errStr := d.categoryFromParam(data.CategoryID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// get target from database
	target, errStr := d.targetFromParam(data.TargetID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// create vulnerability object
	vuln := &mongo.Vulnerability{
		Category: mongo.Category{
			Model: mongo.Model{
				ID: category.ID,
			},
		},
		DetailedTitle: data.DetailedTitle,
		Status:        data.Status,
		References:    data.References,
		GenericRemediation: mongo.VulnerabilityGeneric{
			Enabled: data.GenericRemediation,
		},
		Description: data.Description,
		Remediation: data.Remediation,
		Target: mongo.Target{
			Model: mongo.Model{ID: target.ID},
		},
		Assessment: mongo.Assessment{
			Model: mongo.Model{
				ID: assessment.ID,
			},
		},
		User: mongo.User{
			Model: mongo.Model{
				ID: user.ID,
			},
		},
	}

	// parse CVSS vectors
	errStr = parseAndAssignVulnerabilityCVSS(vuln, data)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// insert vulnerability into database
	vulnerabilityID, err := d.mongo.Vulnerability().Insert(vuln)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Failed to add vulnerability",
		})
	}

	c.Status(fiber.StatusCreated)
	return c.JSON(fiber.Map{
		"message":          "Vulnerability created",
		"vulnerability_id": vulnerabilityID,
	})
}

func (d *Driver) UpdateVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// parse vulnerability param
	vulnerability, errStr := d.vulnerabilityFromParam(c.Params("vulnerability"))
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// retrieve assessment from database
	assessment, err := d.mongo.Assessment().GetByID(vulnerability.Assessment.ID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	// parse request body
	data := &vulnerabilityRequestData{}
	if err := c.BodyParser(data); err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot parse JSON",
		})
	}

	// get category from database
	category, errStr := d.categoryFromParam(data.CategoryID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// get target from database
	target, errStr := d.targetFromParam(data.TargetID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	if target.Customer.ID != assessment.Customer.ID {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid target ID",
		})
	}

	// create vulnerability object
	vuln := &mongo.Vulnerability{
		Category: mongo.Category{
			Model: mongo.Model{
				ID: category.ID,
			},
		},
		DetailedTitle: data.DetailedTitle,
		Status:        data.Status,
		References:    data.References,
		GenericRemediation: mongo.VulnerabilityGeneric{
			Enabled: data.GenericRemediation,
		},
		Description: data.Description,
		Remediation: data.Remediation,
		Target: mongo.Target{
			Model: mongo.Model{ID: target.ID},
		},
	}

	// parse CVSS vectors
	errStr = parseAndAssignVulnerabilityCVSS(vuln, data)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// update vulnerability in database
	err = d.mongo.Vulnerability().Update(vulnerability.ID, vuln)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Failed to update vulnerability",
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(fiber.Map{
		"message": "Vulnerability updated",
	})
}

func (d *Driver) DeleteVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// parse vulnerability param
	vulnerability, errStr := d.vulnerabilityFromParam(c.Params("vulnerability"))
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// retrieve assessment from database
	assessment, err := d.mongo.Assessment().GetByID(vulnerability.Assessment.ID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	// delete vulnerability from database
	err = d.mongo.Vulnerability().Delete(vulnerability.ID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot delete vulnerability",
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(fiber.Map{
		"message": "Vulnerability deleted",
	})
}

func (d *Driver) SearchVulnerabilities(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// if user has not access to any customer, return empty array
	if len(user.Customers) == 0 && user.Role != mongo.RoleAdmin {
		c.Status(fiber.StatusOK)
		return c.JSON([]mongo.Vulnerability{})
	}

	// map user customers ID
	userCustomers := make([]uuid.UUID, len(user.Customers))
	for i, customer := range user.Customers {
		userCustomers[i] = customer.ID
	}

	pagination := util.GetPagination(c.Query("page"), c.Query("limit"))

	// get vulnerabilities from database
	vulnerabilities, err := d.mongo.Vulnerability().Search(
		userCustomers,
		c.Query("query"),
		pagination,
		c.Queries(),
	)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot search vulnerabilities",
			"err":   err.Error(),
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerabilities)
}

func (d *Driver) GetVulnerabilitiesByAssessment(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// parse assessment param
	assessment, errStr := d.assessmentFromParam(c.Params("assessment"))
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	// get vulnerabilities from database
	vulnerabilities, err := d.mongo.Vulnerability().GetByAssessmentID(assessment.ID)
	if err != nil {
		d.logger.Err(err).Msg("Cannot get vulnerabilities")
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get vulnerabilities",
		})
	}

	// set generic description and remediation
	for i := range vulnerabilities {
		// TODO: handle case when category has been deleted, but vulnerability still exists
		category, err := d.mongo.Category().GetByID(vulnerabilities[i].Category.ID)
		if err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(fiber.Map{
				"error": "Cannot get category",
			})
		}

		if vulnerabilities[i].GenericDescription.Enabled {
			vulnerabilities[i].GenericDescription.Text = category.GenericDescription[assessment.Customer.Language]
		}

		if vulnerabilities[i].GenericRemediation.Enabled {
			vulnerabilities[i].GenericRemediation.Text = category.GenericRemediation[assessment.Customer.Language]
		}
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerabilities)
}

func (d *Driver) GetVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// parse vulnerability param
	vulnerabilityParam := c.Params("vulnerability")
	if vulnerabilityParam == "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Vulnerability ID is required",
		})
	}

	vulnerabilityID, err := util.ParseUUID(vulnerabilityParam)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	vulnerability, err := d.mongo.Vulnerability().GetByIDPipeline(vulnerabilityID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// retrieve assessment from database
	assessment, err := d.mongo.Assessment().GetByIDPipeline(vulnerability.Assessment.ID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	category, err := d.mongo.Category().GetByID(vulnerability.Category.ID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get category",
		})
	}

	if vulnerability.GenericDescription.Enabled {
		vulnerability.GenericDescription.Text = category.GenericDescription[assessment.Customer.Language]
	}

	if vulnerability.GenericRemediation.Enabled {
		vulnerability.GenericRemediation.Text = category.GenericRemediation[assessment.Customer.Language]
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerability)
}

func (d *Driver) GetUserVulnerabilities(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	vulnerabilities, err := d.mongo.Vulnerability().GetByUserID(user.ID)
	if err != nil {
		c.Status(fiber.StatusInternalServerError)
		return c.JSON(fiber.Map{
			"error": "Cannot get vulnerabilities",
		})
	}

	c.Status(fiber.StatusOK)
	return c.JSON(vulnerabilities)
}

type copyVulnerabilityRequestData struct {
	AssessmentID string   `json:"assessment_id"`
	TargetIDs    []string `json:"target_ids"`
	IncludePocs  bool     `json:"include_pocs"`
}

func (d *Driver) CopyVulnerability(c *fiber.Ctx) error {
	user := c.Locals("user").(*mongo.User)

	// parse vulnerability param
	vulnerability, errStr := d.vulnerabilityFromParam(c.Params("vulnerability"))
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// retrieve assessment from database
	assessment, err := d.mongo.Assessment().GetByID(vulnerability.Assessment.ID)
	if err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Invalid vulnerability ID",
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(assessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	// parse request body
	data := &copyVulnerabilityRequestData{}
	if err := c.BodyParser(data); err != nil {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": "Cannot parse JSON",
		})
	}

	// retrieve assessment from database
	destAssessment, errStr := d.assessmentFromParam(data.AssessmentID)
	if errStr != "" {
		c.Status(fiber.StatusBadRequest)
		return c.JSON(fiber.Map{
			"error": errStr,
		})
	}

	// check if user has access to customer
	if !user.CanAccessCustomer(destAssessment.Customer.ID) {
		c.Status(fiber.StatusForbidden)
		return c.JSON(fiber.Map{
			"error": "Forbidden",
		})
	}

	//
	vulnerabilityIDs := make([]uuid.UUID, len(data.TargetIDs))
	for i, targetString := range data.TargetIDs {
		target, errStr := d.targetFromParam(targetString)
		if errStr != "" {
			c.Status(fiber.StatusBadRequest)
			return c.JSON(fiber.Map{
				"error": errStr,
			})
		}

		if target.Customer.ID != destAssessment.Customer.ID {
			c.Status(fiber.StatusBadRequest)
			return c.JSON(fiber.Map{
				"error": "Invalid target ID",
			})
		}

		// edit vulnerability object
		vulnerability.Assessment.ID = destAssessment.ID
		vulnerability.Target.ID = target.ID

		// add vulnerability in database
		vulnerabilityID, err := d.mongo.Vulnerability().Copy(vulnerability, data.IncludePocs)
		if err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(fiber.Map{
				"error": "Failed to update vulnerability",
			})
		}

		vulnerabilityIDs[i] = vulnerabilityID
	}

	c.Status(fiber.StatusOK)
	return c.JSON(fiber.Map{
		"message":         "Vulnerability copied",
		"vulnerabilities": vulnerabilityIDs,
	})
}

func parseVulnerabilityCVSS(vectorString string, version string) (*cvss.Vector, error) {
	if vectorString == "" {
		return &cvss.Vector{}, nil
	}

	vector, err := cvss.ParseVector(vectorString, version)
	if err != nil {
		return nil, errors.New("invalid CVSS vector")
	}

	return vector, nil
}

func parseAndAssignVulnerabilityCVSS(vulnerability *mongo.Vulnerability, data *vulnerabilityRequestData) string {
	vector, err := parseVulnerabilityCVSS(data.CVSSv2, cvss.Cvss2)
	if err != nil {
		return "invalid CVSSv2 vector"
	}
	vulnerability.CVSSv2 = *vector

	vector, err = parseVulnerabilityCVSS(data.CVSSv3, cvss.Cvss3)
	if err != nil {
		return "invalid CVSSv3 vector"
	}
	vulnerability.CVSSv3 = *vector

	vector, err = parseVulnerabilityCVSS(data.CVSSv31, cvss.Cvss31)
	if err != nil {
		return "invalid CVSSv31 vector"
	}
	vulnerability.CVSSv31 = *vector

	vector, err = parseVulnerabilityCVSS(data.CVSSv4, cvss.Cvss4)
	if err != nil {
		return "invalid CVSSv4 vector"
	}
	vulnerability.CVSSv4 = *vector

	return ""
}

func (d *Driver) vulnerabilityFromParam(vulnerabilityParam string) (*mongo.Vulnerability, string) {
	if vulnerabilityParam == "" {
		return nil, "Vulnerability ID is required"
	}

	vulnerabilityID, err := util.ParseUUID(vulnerabilityParam)
	if err != nil {
		return nil, "Invalid vulnerability ID"
	}

	vulnerability, err := d.mongo.Vulnerability().GetByID(vulnerabilityID)
	if err != nil {
		return nil, "Invalid vulnerability ID"
	}

	return vulnerability, ""
}
